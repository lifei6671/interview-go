#  删除链表的倒数第n个节点

## 描述

给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针

例如，

给出的链表为:`1→2→3→4→5`,`n=2`.

删除了链表的倒数第 n 个节点之后,链表变为`1→2→3→5`.

数据范围： 链表长度`0≤n≤1000`，链表中任意节点的值满足`0≤val≤100`

要求：空间复杂度`O(1)`，时间复杂度`O(n)`

备注：

题目保证 `n` 一定是有效的

## 示例1

```text
输入：{1,2},2    
返回值：{2} 
```

## 详细解析

```go
/**
 * 删除链表的倒数第 n 个节点，并返回新的头节点。
 *
 * 使用双指针法：
 *   1. fast 先走 n+1 步，使 fast 与 slow 相距 n。
 *   2. 同步移动 fast、slow，直到 fast 走到链表末尾。
 *   3. slow.Next 即为要删除的节点。
 *
 * 为什么使用哨兵节点(dummy)？
 *   - 统一删除逻辑，无需单独判断“删除头节点”的情况。
 *
 * 时间复杂度：O(n)
 * 空间复杂度：O(1)
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    // 创建哨兵节点，next 指向原链表头部
    dummy := &ListNode{Next: head}
    slow := dummy
    fast := dummy

    // fast 先走 n+1 步，使 slow 停在倒数第 n+1 个节点位置
    for i := 0; i <= n; i++ {
        // 如果 n 超过链表长度，fast 会提前为 nil，直接返回原链表
        if fast == nil {
            return head
        }
        fast = fast.Next
    }

    // fast 与 slow 同步前进
    for fast != nil {
        slow = slow.Next
        fast = fast.Next
    }

    // 此时 slow.Next 为倒数第 n 个节点，将其删除
    slow.Next = slow.Next.Next

    // dummy.Next 为新的链表头节点
    return dummy.Next
}
```

---

### 逻辑图解

假设链表为：

```
dummy → 1 → 2 → 3 → 4 → 5
```

删除倒数第 2 个节点（即 4）。

fast 先走 n+1 = 3 步：

```
i=0 → fast=1
i=1 → fast=2
i=2 → fast=3
```

然后 fast、slow 一起走，直到 fast 到 nil：

```
slow → 3
fast → nil
```

现在 slow.Next 即 4，将其删除：

```
3 → 5
```

---

### 为什么 fast 走 n+1 步？

这能让 slow 停在“倒数第 n+1 个节点”，从而 `slow.Next` 正好是倒数第 n 个节点。
这样就可以轻松删除，不需要特别处理头节点。

